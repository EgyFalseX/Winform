/*
	Copyright (c) 2008 Drew Benton (pushedx)

	This software is provided 'as-is', without any express or implied
	warranty. In no event will the authors be held liable for any damages
	arising from the use of this software.

	Permission is granted to anyone to use this software for any purpose,
	including commercial applications, and to alter it and redistribute it
	freely, subject to the following restrictions:

	1. The origin of this software must not be misrepresented; you must not
	claim that you wrote the original software. If you use this software
	in a product, an acknowledgment in the product documentation would be
	appreciated but is not required.

	2. Altered source versions must be plainly marked as such, and must not be
	misrepresented as being the original software.

	3. This notice may not be removed or altered from any source
	distribution.
*/

//-----------------------------------------------------------------------------

#define _CRT_SECURE_NO_WARNINGS

#ifndef _WINSOCK2API_
	#include <winsock2.h>
#endif

#ifndef _WS2TCPIP_H_
	#include <ws2tcpip.h>
#endif

#include "edxTCPNetwork.h"

#pragma comment(lib, "ws2_32.lib")

//-----------------------------------------------------------------------------

// Defines for the custom WSAA messages
#define WSAA_MSG1		(WM_USER + 500)
#define WSAA_MSG2		(WM_USER + 501)

// The largest size a complete packet can be, used for recv() as well as
// the stream parsing buffer size
#define MAX_PACKET_SIZE 8192

// The onTimer invoke delay (ms)
#define gTimerId 1000
#define uElapse 500

//-----------------------------------------------------------------------------

// Network thread structure
struct tServerThreadStructServer
{
	edx::BaseTCPServer * server;
};

// Network thread structure
struct tNetworkThreadStructClient
{
	edx::BaseTCPClient * client;
	CHAR address[1024];
	INT port;
	BOOL doHostLookUp;
};

// Packet buffer struct for queued sending
struct edx::tPacketBuffer
{
	WORD index;
	WORD size;
	CHAR data[MAX_PACKET_SIZE];
};

//-----------------------------------------------------------------------------

// Returns a hostent object with the information about a host
hostent * GetHost(const char * host);

//-----------------------------------------------------------------------------

// Initialize the Winsock library
bool edx::InitializeWinsock(BYTE major, BYTE minor)
{
	// Error variables
	TCHAR lastError[4096] = {0};
	DWORD dwError = 0;

	// Winsock data
	WSADATA wsaData = {0};

	// Try to start the winsock library
	dwError = WSAStartup(MAKEWORD(major, minor), &wsaData);
	if(dwError != ERROR_SUCCESS)
	{
		// Handle the error
		switch(dwError)
		{
			case WSASYSNOTREADY: _sntprintf(lastError, 4095, TEXT("The underlying network subsystem is not ready for network communication.")); break;
			case WSAVERNOTSUPPORTED: _sntprintf(lastError, 4095, TEXT("The version of Windows Sockets support requested is not provided by this particular Windows Sockets implementation.")); break;
			case WSAEINPROGRESS: _sntprintf(lastError, 4095, TEXT("A blocking Windows Sockets 1.1 operation is in progress.")); break;
			case WSAEPROCLIM: _sntprintf(lastError, 4095, TEXT("A limit on the number of tasks supported by the Windows Sockets implementation has been reached.")); break;
			case WSAEFAULT: _sntprintf(lastError, 4095, TEXT("The lpWSAData parameter is not a valid pointer.")); break;
			default: _sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by WSAStartup."), dwError);
		}

		// Show the error
		MessageBox(0, lastError, TEXT("Error"), MB_ICONERROR);

		// Signal error
		return false;
	}

	// Verify the version of winsock we wish to use is supported
	if(LOBYTE(wsaData.wVersion) != major || HIBYTE(wsaData.wVersion) != minor)
	{
		// Clean up the winsock library
		WSACleanup();

		// Build the error message
		_sntprintf(lastError, 4095, TEXT("Winsock version %i.%i is not supported on this computer. Only version %i.%i."), major, minor, LOBYTE(wsaData.wVersion), HIBYTE(wsaData.wVersion));

		// Show the error
		MessageBox(0, lastError, TEXT("Error"), MB_ICONERROR);

		// Signal error
		return false;
	}

	// Success
	return true;
}

//-----------------------------------------------------------------------------

// Deinitialize the Winsock library
void edx::DeinitializeWinsock()
{
	// Clean up the winsock library
	WSACleanup();
}

//-----------------------------------------------------------------------------

// Returns a hostent object with the information about a host
hostent * GetHost(const char * host)
{
	if(inet_addr(host) == INADDR_NONE)
	{
		return gethostbyname(host);
	}
	else
	{
		unsigned long addr = 0;
		addr = inet_addr(host);
		return gethostbyaddr((char*)&addr, sizeof(addr), AF_INET);
	}
}

//-----------------------------------------------------------------------------

edx::TCPInterface::TCPInterface()
{
}

//-----------------------------------------------------------------------------

edx::TCPInterface::~TCPInterface()
{
}

//-----------------------------------------------------------------------------

// Default ctor
edx::BaseTCPServer::BaseTCPServer()
{
	sSocket = INVALID_SOCKET;
	port = 0;
	hNetworkThread = NULL;
	hNetworkThreadId = 0;
	hNetworkWnd = NULL;
	bExit = 0;
	bTmpVar = 0;
	hTmpEvent = NULL;
	memset(&NetworkWindowClass, 0, sizeof(NetworkWindowClass));
	memset(className, 0, 32 * sizeof(className[0]));
	hAcceptEvent = NULL;
}

//-----------------------------------------------------------------------------

// Default dtor
edx::BaseTCPServer::~BaseTCPServer()
{
}

//-----------------------------------------------------------------------------

// Creates a server on the specific port and returns the socket
bool edx::BaseTCPServer::Create(WORD listenPort, bool bAllowConnections)
{
	// Error variables
	TCHAR lastError[4096] = {0};
	DWORD dwError = 0;

	// Address info
	addrinfo * results = NULL;
	addrinfo hints = {0};
	CHAR portname[8] = {0};

	// Port to listen on
	port = listenPort;

	// Convert and store the desired port
	_snprintf(portname, 7, "%i", port);

	// Setup the hints
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	hints.ai_flags = AI_PASSIVE;

	// Generate a temp class name
	for(INT x = 0; x < 31; ++x)
	{
		INT val = rand() % 100;
		if(val >= 0 && val < 33)
			className[x] = (TCHAR)('A' + (rand() % 26));
		else if(val >= 33 && val < 66)
			className[x] = (TCHAR)('a' + (rand() % 26));
		else
			className[x] = (TCHAR)('0' + (rand() % 10));
	}

	// Store the window class information and register it
	NetworkWindowClass.lpfnWndProc = (WNDPROC)ServerWndProc;
	NetworkWindowClass.hInstance = GetModuleHandle(0);
	NetworkWindowClass.lpszClassName = className;

	// Try and register the class
	if(!RegisterClass(&NetworkWindowClass))
	{
		// Build the error message
		_sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by RegisterClass."), dwError);

		// Call the error function
		OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

		// Signal error
		return false;
	}

	// Try to get the address info
	dwError = getaddrinfo(NULL, portname, &hints, &results);
	if(dwError != 0)
	{
		// Handle the error
		switch(dwError)
		{
			case WSATRY_AGAIN: _sntprintf(lastError, 4095, TEXT("A temporary failure in name resolution occurred.")); break;
			case WSAEINVAL: _sntprintf(lastError, 4095, TEXT("An invalid value was provided for the ai_flags member of the hints parameter.")); break;
			case WSANO_RECOVERY: _sntprintf(lastError, 4095, TEXT("A nonrecoverable failure in name resolution occurred.")); break;
			case WSAEAFNOSUPPORT: _sntprintf(lastError, 4095, TEXT("The ai_family member of the hints parameter is not supported.")); break;
			case WSA_NOT_ENOUGH_MEMORY: _sntprintf(lastError, 4095, TEXT("A memory allocation failure occurred.")); break;
			case WSAHOST_NOT_FOUND: _sntprintf(lastError, 4095, TEXT("The name does not resolve for the supplied parameters or the nodename and servname parameters were not provided.")); break;
			case WSATYPE_NOT_FOUND: _sntprintf(lastError, 4095, TEXT("The servname parameter is not supported for the specified ai_socktype member of the hints parameter.")); break;
			case WSAESOCKTNOSUPPORT: _sntprintf(lastError, 4095, TEXT("The ai_socktype member of the hints parameter is not supported.")); break;
			default: _sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by getaddrinfo."), dwError);
		}

		// Free class name
		UnregisterClass(className, GetModuleHandle(0));

		// Call the error function
		OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

		// Failure
		return false;
	}

	// Create the main socket for the server
	sSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
	if(sSocket == INVALID_SOCKET)
	{
		// Handle the error
		dwError = WSAGetLastError();
		switch(dwError)
		{
			case WSANOTINITIALISED: _sntprintf(lastError, 4095, TEXT("A successful WSAStartup call must occur before using this function.")); break;
			case WSAENETDOWN: _sntprintf(lastError, 4095, TEXT("The network subsystem has failed.")); break;
			case WSAEAFNOSUPPORT: _sntprintf(lastError, 4095, TEXT("The specified address family is not supported.")); break;
			case WSAEINPROGRESS: _sntprintf(lastError, 4095, TEXT("A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.")); break;
			case WSAEMFILE: _sntprintf(lastError, 4095, TEXT("No more socket descriptors are available.")); break;
			case WSAENOBUFS: _sntprintf(lastError, 4095, TEXT("No buffer space is available. The socket cannot be created.")); break;
			case WSAEPROTONOSUPPORT: _sntprintf(lastError, 4095, TEXT("The specified protocol is not supported.")); break;
			case WSAEPROTOTYPE: _sntprintf(lastError, 4095, TEXT("The specified protocol is the wrong type for this socket.")); break;
			case WSAESOCKTNOSUPPORT: _sntprintf(lastError, 4095, TEXT("The specified socket type is not supported in this address family.")); break;
			case WSAEINVAL: _sntprintf(lastError, 4095, TEXT("This value is true for any of the following conditions.:\n\t* The parameter g specified is not valid.\n\t* The WSAPROTOCOL_INFO structure that lpProtocolInfo points to is incomplete, the contents are invalid or the WSAPROTOCOL_INFO structure has already been used in an earlier duplicate socket operation.\n\t* The values specified for members of the socket triple <af, type, and protocol> are individually supported, but the given combination is not.")); break;
			case WSAEFAULT: _sntprintf(lastError, 4095, TEXT("The lpProtocolInfo parameter is not in a valid part of the process address space.")); break;
			default: _sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by WSASocket."), dwError);
		}

		// Free class name
		UnregisterClass(className, GetModuleHandle(0));

		// Cleanup on error
		freeaddrinfo(results);

		// Call the error function
		OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

		// Failure
		return false;
	}

	// Bind the socket
	dwError = bind(sSocket, (SOCKADDR*)results->ai_addr, (INT)results->ai_addrlen);

	// Free the address info since we do not need it anymore
	freeaddrinfo(results);

	// Make sure it was bound
	if(dwError == SOCKET_ERROR)
	{
		// Handle the error
		dwError = WSAGetLastError();
		switch(dwError)
		{
			case WSANOTINITIALISED: _sntprintf(lastError, 4095, TEXT("A successful WSAStartup call must occur before using this function.")); break;
			case WSAENETDOWN: _sntprintf(lastError, 4095, TEXT("The network subsystem has failed.")); break;
			case WSAEACCES: _sntprintf(lastError, 4095, TEXT("Attempt to connect datagram socket to broadcast address failed because setsockopt option SO_BROADCAST is not enabled.")); break;
			case WSAEADDRINUSE: _sntprintf(lastError, 4095, TEXT("A process on the computer is already bound to the same fully-qualified address and the socket has not been marked to allow address reuse with SO_REUSEADDR. For example, the IP address and port are bound in the af_inet case). (See the SO_REUSEADDR socket option under setsockopt.)\n")); break;
			case WSAEADDRNOTAVAIL: _sntprintf(lastError, 4095, TEXT("The specified address is not a valid address for this computer.")); break;
			case WSAEFAULT: _sntprintf(lastError, 4095, TEXT("The name or namelen parameter is not a valid part of the user address space, the namelen parameter is too small, the name parameter contains an incorrect address format for the associated address family, or the first two bytes of the memory block specified by name does not match the address family associated with the socket descriptor s.")); break;
			case WSAEINPROGRESS: _sntprintf(lastError, 4095, TEXT("A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.")); break;
			case WSAEINVAL: _sntprintf(lastError, 4095, TEXT("The socket is already bound to an address.")); break;
			case WSAENOBUFS: _sntprintf(lastError, 4095, TEXT("Not enough buffers available, too many connections.")); break;
			case WSAENOTSOCK: _sntprintf(lastError, 4095, TEXT("The descriptor is not a socket.")); break;
			default: _sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by bind."), dwError);
		}

		// Free class name
		UnregisterClass(className, GetModuleHandle(0));

		// Cleanup on error
		closesocket(sSocket);

		// Clear the socket
		sSocket = INVALID_SOCKET;

		// Call the error function
		OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

		// Failure
		return false;
	}

	// Listen for incoming connections
	dwError = listen(sSocket, SOMAXCONN);
	if(dwError == SOCKET_ERROR)
	{
		// Handle the error
		dwError = WSAGetLastError();
		switch(dwError)
		{
			case WSANOTINITIALISED: _sntprintf(lastError, 4095, TEXT("A successful WSAStartup call must occur before using this function.")); break;
			case WSAENETDOWN: _sntprintf(lastError, 4095, TEXT("The network subsystem has failed.")); break;
			case WSAEADDRINUSE: _sntprintf(lastError, 4095, TEXT("The socket's local address is already in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This error usually occurs during execution of the bind function, but could be delayed until this function if the bind was to a partially wildcard address (involving ADDR_ANY) and if a specific address needs to be committed at the time of this function.")); break;
			case WSAEINPROGRESS: _sntprintf(lastError, 4095, TEXT("A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.")); break;
			case WSAEINVAL: _sntprintf(lastError, 4095, TEXT("The socket has not been bound with bind.")); break;
			case WSAEISCONN: _sntprintf(lastError, 4095, TEXT("The socket is already connected.")); break;
			case WSAEMFILE: _sntprintf(lastError, 4095, TEXT("No more socket descriptors are available.")); break;
			case WSAENOBUFS: _sntprintf(lastError, 4095, TEXT("No buffer space is available.")); break;
			case WSAENOTSOCK: _sntprintf(lastError, 4095, TEXT("The descriptor is not a socket.")); break;
			case WSAEOPNOTSUPP: _sntprintf(lastError, 4095, TEXT("The referenced socket is not of a type that supports the listen operation.")); break;
			default: _sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by listen."), dwError);
		}

		// Free class name
		UnregisterClass(className, GetModuleHandle(0));

		// Cleanup on error
		closesocket(sSocket);

		// Clear the socket
		sSocket = INVALID_SOCKET;

		// Call the error function
		OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

		// Failure
		return false;
	}

	// Name of the temp event
	TCHAR eventName[32] = {0};

	// Generate a random name
	for(INT x = 0; x < 31; ++x)
	{
		INT val = rand() % 100;
		if(val >= 0 && val < 33)
			eventName[x] = (TCHAR)('A' + (rand() % 26));
		else if(val >= 33 && val < 66)
			eventName[x] = (TCHAR)('a' + (rand() % 26));
		else
			eventName[x] = (TCHAR)('0' + (rand() % 10));
	}

	// The event that can be set to allow or disallow connections
	hAcceptEvent = CreateEvent(0, TRUE, FALSE, eventName);

	// If we are not accepting connections, set the event to signal it
	if(bAllowConnections == false)
	{
		SetEvent(hAcceptEvent);
	}

	// Allocate memory for a new parameter, deleted at the end of the NetworkThread function
	tServerThreadStructServer * params = new (std::nothrow) tServerThreadStructServer;

	// Make sure the allocation did not fail
	if(params == 0)
	{
		// Free the event handle
		CloseHandle(hAcceptEvent);

		// Free class name
		UnregisterClass(className, GetModuleHandle(0));

		// Cleanup on error
		closesocket(sSocket);

		// Clear the socket
		sSocket = INVALID_SOCKET;

		// Call the error function
		OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, TEXT("Not enough memory to allocate a tServerThreadStructServer object."));

		// Failure
		return false;
	}

	// Clear out memory
	memset(params, 0, sizeof(tServerThreadStructServer));

	// Generate a random name
	for(INT x = 0; x < 31; ++x)
	{
		INT val = rand() % 100;
		if(val >= 0 && val < 33)
			eventName[x] = ('A' + (TCHAR)(rand() % 26));
		else if(val >= 33 && val < 66)
			eventName[x] = 'a' + (TCHAR)((rand() % 26));
		else
			eventName[x] = '0' + (TCHAR)((rand() % 10));
	}

	// Store the server object address into the thread parameter object
	params->server = this;

	// Create the thread - assume it is created
	hNetworkThread = CreateThread(0, 0, ServerThread, params, CREATE_SUSPENDED, &hNetworkThreadId);

	// Create a temp event to sync threads 
	hTmpEvent = CreateEvent(0, TRUE, FALSE, eventName);

	// Resume the thread after all data has been filled out
	ResumeThread(hNetworkThread);

	// Wait for the signal
	WaitForSingleObject(hTmpEvent, INFINITE);

	// Done with the handle now
	CloseHandle(hTmpEvent);

	// Clear it out
	hTmpEvent = 0;

	// Check to see if there was an error
	if(bTmpVar == FALSE)
	{
		// Close the socket
		closesocket(sSocket);

		// Clear the handle
		sSocket = INVALID_SOCKET;

		// Close the accept event handle
		CloseHandle(hAcceptEvent);

		// Clear the handle
		hAcceptEvent = NULL;

		// Free class name
		UnregisterClass(className, GetModuleHandle(0));

		// Failure
		return false;
	}

	// Success, return the socket
	return true;
}

//-----------------------------------------------------------------------------

// Destroys the server
void edx::BaseTCPServer::Destroy()
{
	// Mark the server as needing to exit
	bExit = TRUE;

	// Close the socket
	closesocket(sSocket);

	// Clear the handle
	sSocket = INVALID_SOCKET;

	// Allow connections to breakout of our sleep loop
	AllowConnections(true);

	// Send the quit message to the network event window
	PostMessage(hNetworkWnd, WM_QUIT, 0, 0);

	// Post thread quit message in case there is no message processing loop
	PostThreadMessage(hNetworkThreadId, WM_QUIT, 0, 0);

	// Wait for the thread to complete, should not take long unless we have a blocking condition / deadlock
	if(WaitForSingleObject(hNetworkThread, 1000) == WAIT_TIMEOUT)
		TerminateThread(hNetworkThread, 0);

	// Done with this event
	CloseHandle(hAcceptEvent);
}

//-----------------------------------------------------------------------------

// Allows or disallows incoming connections
void edx::BaseTCPServer::AllowConnections(bool bAllow)
{
	// We are allowing connections
	if(bAllow)
	{
		ResetEvent(hAcceptEvent);
	}
	else
	{
		SetEvent(hAcceptEvent);
	}
}

//-----------------------------------------------------------------------------

// The thread function that handles network traffic for the login server
DWORD WINAPI edx::BaseTCPServer::ServerThread(LPVOID lpParam)
{
	// Error variables
	TCHAR lastError[4096] = {0};
	DWORD dwError = 0;

	// Store the thread structure
	tServerThreadStructServer * params = (tServerThreadStructServer *)lpParam;

	// No error
	params->server->bTmpVar = false;

	// Make sure we have a valid socket
	if(params->server->sSocket == INVALID_SOCKET)
	{
		// Call the error function
		params->server->OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, TEXT("Invalid socket specified in the server object."));

		// Delete the memory allocated previously
		delete params;

		// Signal the other thread
		SetEvent(params->server->hTmpEvent);

		// Done with the thread
		return 0;
	}

	// Create the network message hwnd
	params->server->hNetworkWnd = CreateWindowEx(0, params->server->className, TEXT(""), 0, 0, 0, 0, 0, NULL, NULL, GetModuleHandle(0), NULL);

	// Make sure it was created
	if(params->server->hNetworkWnd == NULL)
	{
		// Build the error message
		_sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by CreateWindowEx."), dwError);

		// Call the error function
		params->server->OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

		// Delete the memory allocated previously
		delete params;

		// Signal the other thread
		SetEvent(params->server->hTmpEvent);

		// Done with the thread
		return 0;
	}

	// Set the pointer for the window
	SetWindowLong(params->server->hNetworkWnd, GWL_USERDATA, PtrToUlong(params->server));

	// Allow the socket to be notified of accept events
	WSAAsyncSelect(params->server->sSocket, params->server->hNetworkWnd, WSAA_MSG2, FD_ACCEPT);

	// No error
	params->server->bTmpVar = true;

	// Signal the other thread
	SetEvent(params->server->hTmpEvent);

	// Store the window handle
	HWND h = params->server->hNetworkWnd;

	// Delete the memory allocated previously
	delete params;

	// Setup a timer for regular updating
	SetTimer(h, gTimerId, uElapse, 0);

	// Process while we have a message queue
	MSG Msg = {0};
	while(GetMessage(&Msg, 0, 0, 0) > 0)
	{
		TranslateMessage(&Msg);
		DispatchMessage(&Msg);
	}

	// Done with the window
	DestroyWindow(h);

	// Standard return
	return 0;
}

//-----------------------------------------------------------------------------

// This is the network message handling callback function
LRESULT CALLBACK edx::BaseTCPServer::ServerWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	// Get the server associated with the HWND
	BaseTCPServer * server = (BaseTCPServer *)UlongToPtr(GetWindowLong(hWnd, GWL_USERDATA));

	// Network message variables
	SOCKET currentSocket = 0;
	DWORD event = 0;
	DWORD dwError = 0;
	TCHAR lastError[4096] = {0};

	// Handle the message
	switch(uMsg)
	{
	case WM_TIMER:
		{
			if(wParam == gTimerId)
			{
				// No server to handle the network event
				if(server == 0)
				{
					return 0;
				}

				// Call the timer event
				server->OnTimer();
			}
		} break;

		// Quit message
	case WM_QUIT:
		{
			// If we have a valid server object
			if(server)
			{
				// Post the exit message
				PostThreadMessage(server->hNetworkThreadId, WM_QUIT, 0, 0);
			}
		} break;

		// Custom network event
	case WSAA_MSG1:
		{
			// Store the network event
			event = WSAGETSELECTEVENT(lParam);

			// Store the network error
			dwError = WSAGETSELECTERROR(lParam);

			// Store the current socket
			currentSocket = wParam;

			// No server to handle the network event
			if(server == 0)
			{
				return 0;
			}

			// Network is down 
			if(dwError == WSAENETDOWN)
			{
				// Error string
				TCHAR lastError[4096] = {0};

				// Build the error
				_sntprintf(lastError, 4095, TEXT("The network subsystem has failed."));

				// Call the error function
				server->OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

				// Do not forward this message
				return 0;
			}

			// Read event
			if(event == FD_READ)
			{
				server->OnRead(currentSocket);
			}
			// Write event
			else if(event == FD_WRITE)
			{
				server->OnWrite(currentSocket);
			}
			// Close event
			else if(event == FD_CLOSE)
			{
				server->OnClose(currentSocket);
				closesocket(currentSocket);
			}

			// Do not forward this message
			return 0;
		} break;

		// Custom network event - accepting
	case WSAA_MSG2:
		{
			// Store the network event
			event = WSAGETSELECTEVENT(lParam);

			// Store the network error
			dwError = WSAGETSELECTERROR(lParam);

			// Store the current socket
			currentSocket = wParam;

			// No server to handle the network event
			if(server == 0)
			{
				return 0;
			}

			// Network is down 
			if(dwError == WSAENETDOWN)
			{
				// Error string
				TCHAR lastError[4096] = {0};

				// Build the error
				_sntprintf(lastError, 4095, TEXT("The network subsystem has failed."));

				// Call the error function
				server->OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

				// Do not forward this message
				return 0;
			}

			// Accept event
			if(event == FD_ACCEPT)
			{
				// Connecting socket
				SOCKET clientSocket = INVALID_SOCKET;

				// Accept a connection
				clientSocket = accept(currentSocket, 0, 0);

				// If the connection is invalid, find out why
				if(clientSocket == INVALID_SOCKET || clientSocket == SOCKET_ERROR)
				{
					// If we are exiting, ignore errors
					if(server->bExit)
						break;

					// Handle the error
					dwError = WSAGetLastError();
					switch(dwError)
					{
						case WSANOTINITIALISED: _sntprintf(lastError, 4095, TEXT("A successful WSAStartup call must occur before using this function.")); break;
						case WSAECONNRESET: _sntprintf(lastError, 4095, TEXT("An incoming connection was indicated, but was subsequently terminated by the remote peer prior to accepting the call.")); break;
						case WSAEFAULT: _sntprintf(lastError, 4095, TEXT("The addrlen parameter is too small or addr is not a valid part of the user address space.")); break;
						case WSAEINTR: _sntprintf(lastError, 4095, TEXT("A blocking Windows Sockets 1.1 call was canceled through WSACancelBlockingCall.")); break;
						case WSAEINVAL: _sntprintf(lastError, 4095, TEXT("The listen function was not invoked prior to accept.")); break;
						case WSAEINPROGRESS: _sntprintf(lastError, 4095, TEXT("A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.")); break;
						case WSAEMFILE: _sntprintf(lastError, 4095, TEXT("The queue is nonempty upon entry to accept and there are no descriptors available.")); break;
						case WSAENETDOWN: _sntprintf(lastError, 4095, TEXT("The network subsystem has failed.")); break;
						case WSAENOBUFS: _sntprintf(lastError, 4095, TEXT("No buffer space is available.")); break;
						case WSAENOTSOCK: _sntprintf(lastError, 4095, TEXT("The descriptor is not a socket.")); break;
						case WSAEOPNOTSUPP: _sntprintf(lastError, 4095, TEXT("The referenced socket is not a type that supports connection-oriented service.")); break;
						case WSAEWOULDBLOCK: _sntprintf(lastError, 4095, TEXT("The socket is marked as nonblocking and no connections are present to be accepted.")); break;
						default: _sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by accept."), dwError);
					}

					// Call the error function
					server->OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

					// Break out of the loop
					break;
				}

				// Check to see if we should accept connections
				if((server->bExit == TRUE) || (WaitForSingleObject(server->hAcceptEvent, 0) == WAIT_OBJECT_0) && (server->bExit == FALSE))
				{
					// Close the connection
					shutdown(clientSocket, 0x02);
				}
				else
				{
					// Assign network events for the socket to go to the network window
					dwError = WSAAsyncSelect(clientSocket, server->hNetworkWnd, WSAA_MSG1, FD_READ | FD_CLOSE | FD_WRITE);

					// Check for an error
					if(dwError == SOCKET_ERROR)
					{
						// Get the error
						dwError = WSAGetLastError();

						// Handle the error
						switch(dwError)
						{
							case WSANOTINITIALISED: _sntprintf(lastError, 4095, TEXT("A successful WSAStartup call must occur before using this function.\n")); break;
							case WSAENETDOWN: _sntprintf(lastError, 4095, TEXT("The network subsystem failed.\n")); break;
							case WSAEINVAL: _sntprintf(lastError, 4095, TEXT("One of the specified parameters was invalid, such as the window handle not referring to an existing window, or the specified socket is in an invalid state.\n")); break;
							case WSAEINPROGRESS: _sntprintf(lastError, 4095, TEXT("A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.\n")); break;
							case WSAENOTSOCK: _sntprintf(lastError, 4095, TEXT("The descriptor is not a socket.\n")); break;
							default: _sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by WSAAsyncSelect.\n"), dwError);
						}

						// Call the error function
						server->OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

						// Close the socket
						closesocket(clientSocket);

						// Done with the event
						break;
					}

					// A client has connected, now send it to the user's function
					server->OnConnect(clientSocket);
				}
			}

			// Do not forward this message
			return 0;
		} break;
	}

	// Default handler
	return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//-----------------------------------------------------------------------------

// Default ctor
edx::BaseTCPClient::BaseTCPClient()
{
	sSocket = INVALID_SOCKET;
	hNetworkThread = NULL;
	hNetworkThreadId = 0;
	hNetworkWnd = NULL;
	bExit = FALSE;
	bTmpVar = FALSE;
	hTmpEvent = NULL;
	memset(&NetworkWindowClass, 0, sizeof(NetworkWindowClass));
	memset(className, 0, sizeof(className));
	hInstance = GetModuleHandle(0);
	iConnected = -1;
}

//-----------------------------------------------------------------------------

// Default dtor
edx::BaseTCPClient::~BaseTCPClient()
{
}

//-----------------------------------------------------------------------------

// Connect to a destination ip address and port
bool edx::BaseTCPClient::Connect(const char * address, INT port, bool doHostLookUp)
{
	// Last error integer
	DWORD dwError = 0;

	// Last error string
	TCHAR lastError[4096] = {0};

	srand(GetTickCount());

	// Generate a temp class name
	for(INT x = 0; x < 31; ++x)
	{
		INT val = rand() % 100;
		if(val >= 0 && val < 33)
			className[x] = (TCHAR)('A' + (rand() % 26));
		else if(val >= 33 && val < 66)
			className[x] = (TCHAR)('a' + (rand() % 26));
		else
			className[x] = (TCHAR)('0' + (rand() % 10));
	}

	// Store the window class information and register it
	NetworkWindowClass.lpfnWndProc = (WNDPROC)ClientWndProc;
	NetworkWindowClass.hInstance = hInstance;
	NetworkWindowClass.lpszClassName = className;

	// Try and register the class
	if(!RegisterClass(&NetworkWindowClass))
	{
		// Build the error message
		_sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by RegisterClass."), dwError);

		// Call the error function
		OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

		// Signal error
		return false;
	}

	// Name of the temp event
	TCHAR eventName[32] = {0};

	// Allocate memory for a new parameter, deleted at the end of the NetworkThread function
	tNetworkThreadStructClient * params = new (std::nothrow) tNetworkThreadStructClient;

	// Make sure the allocation did not fail
	if(params == 0)
	{
		// Free class name
		UnregisterClass(className, GetModuleHandle(0));

		// Call the error function
		OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, TEXT("Not enough memory to allocate a tNetworkThreadStructClient object."));

		// Failure
		return false;
	}

	// Clear out memory
	memset(params, 0, sizeof(tNetworkThreadStructClient));

	// Store the client object address into the thread parameter object
	params->client = this;

	// Save the port to connect to
	params->port = port;

	// Save if we should be doing a host lookup
	params->doHostLookUp = doHostLookUp;

	// Save the address to connect to
	_snprintf(params->address, 1023, "%s", address);

	// Generate a random name
	for(INT x = 0; x < 31; ++x)
	{
		INT val = rand() % 100;
		if(val >= 0 && val < 33)
			eventName[x] = (TCHAR)('A' + (rand() % 26));
		else if(val >= 33 && val < 66)
			eventName[x] = (TCHAR)('a' + (rand() % 26));
		else
			eventName[x] = (TCHAR)('0' + (rand() % 10));
	}

	// Create a temp event to sync threads 
	hTmpEvent = CreateEvent(0, TRUE, FALSE, eventName);

	// Create the thread - assume it is created
	hNetworkThread = CreateThread(0, 0, ClientThread, params, CREATE_SUSPENDED, &hNetworkThreadId);

	// Resume the thread after all data has been filled out
	ResumeThread(hNetworkThread);

	// Wait for the signal
	WaitForSingleObject(hTmpEvent, INFINITE);

	// Done with the handle now
	CloseHandle(hTmpEvent);

	// Clear it out
	hTmpEvent = 0;

	// Check to see if there was an error
	if(bTmpVar == FALSE)
	{
		// Clear the thread handle
		hNetworkThread = NULL;

		// Clear the thread id
		hNetworkThreadId = 0;

		// Free class name
		UnregisterClass(className, hInstance);

		// Free allocated memory
		delete params;

		// Failure
		return false;
	}

	// How long before we assume a timeout (give 5s for a connection)
	DWORD timeOut = GetTickCount() + 5000;

	// Wait for the connection, block;
	while(iConnected == -1)
	{
		// Eat time
		Sleep(100);

		// Make sure we do not loop forever
		if(GetTickCount() > timeOut)
			break;
	}

	// Success
	return (iConnected == 1);
}

//-----------------------------------------------------------------------------

// Destroys the client
void edx::BaseTCPClient::Destroy()
{
	// Mark the client as needing to exit
	bExit = TRUE;

	// Close the socket
	closesocket(sSocket);

	// Clear the value
	sSocket = INVALID_SOCKET;

	// Send the quit message to the network event window
	PostMessage(hNetworkWnd, WM_QUIT, 0, 0);

	// Post thread quit message in case there is no message processing loop
	PostThreadMessage(hNetworkThreadId, WM_QUIT, 0, 0);

	// Wait for the thread to complete, should not take long unless we have a blocking condition / deadlock
	if(WaitForSingleObject(hNetworkThread, 1000) == WAIT_TIMEOUT)
		TerminateThread(hNetworkThread, 0);

	// Free the class name used
	UnregisterClass(className, hInstance);
}

//-----------------------------------------------------------------------------

// Returns true of this client was able to connect to the server. 
bool edx::BaseTCPClient::IsConnected() const
{
	return (iConnected == 1);
}

//-----------------------------------------------------------------------------

// The thread function that handles network traffic
DWORD WINAPI edx::BaseTCPClient::ClientThread(LPVOID lpParam)
{
	// Host information
	hostent * host = 0;

	// Server address information
	sockaddr_in server = {0};

	// Error variables
	TCHAR lastError[4096] = {0};
	DWORD dwError = 0;

	// Store the thread structure
	tNetworkThreadStructClient * params = (tNetworkThreadStructClient *)lpParam;

	// Check to see if the parameter is valid
	if(params == NULL)
	{
		// Build the error message
		_sntprintf(lastError, 4095, TEXT("No valid parameter passed into ClientThread.\n"));

		// Call the error function
		params->client->OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

		// Signal the other thread
		SetEvent(params->client->hTmpEvent);

		// Done with the thread
		return 0;
	}

	// Start out assuming an error
	params->client->bTmpVar = FALSE;

	// Create the network message hwnd
	params->client->hNetworkWnd = CreateWindowEx(0, params->client->className, TEXT(""), 0, 0, 0, 0, 0, NULL, NULL, params->client->hInstance, NULL);

	// Make sure it was created
	if(params->client->hNetworkWnd == NULL)
	{
		// Build the error message
		_sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by CreateWindowEx."), dwError);

		// Call the error function
		params->client->OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

		// Signal the other thread
		SetEvent(params->client->hTmpEvent);

		// Done with the thread
		return 0;
	}

	// Set the pointer for the window
	SetWindowLong(params->client->hNetworkWnd, GWL_USERDATA, PtrToUlong(params->client));

	// Try to create a socket to use
	params->client->sSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
	if(params->client->sSocket == INVALID_SOCKET)
	{
		// Get the error
		dwError = WSAGetLastError();

		// Handle the error
		switch(dwError)
		{
			case WSANOTINITIALISED: _sntprintf(lastError, 4095, TEXT("A successful WSAStartup call must occur before using this function.\n")); break;
			case WSAENETDOWN: _sntprintf(lastError, 4095, TEXT("The network subsystem has failed.\n")); break;
			case WSAEAFNOSUPPORT: _sntprintf(lastError, 4095, TEXT("The specified address family is not supported.\n")); break;
			case WSAEINPROGRESS: _sntprintf(lastError, 4095, TEXT("A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.\n")); break;
			case WSAEMFILE: _sntprintf(lastError, 4095, TEXT("No more socket descriptors are available.\n")); break;
			case WSAENOBUFS: _sntprintf(lastError, 4095, TEXT("No buffer space is available. The socket cannot be created.\n")); break;
			case WSAEPROTONOSUPPORT: _sntprintf(lastError, 4095, TEXT("The specified protocol is not supported.\n")); break;
			case WSAEPROTOTYPE: _sntprintf(lastError, 4095, TEXT("The specified protocol is the wrong type for this socket.\n")); break;
			case WSAESOCKTNOSUPPORT: _sntprintf(lastError, 4095, TEXT("The specified socket type is not supported in this address family.\n")); break;
			case WSAEINVAL: _sntprintf(lastError, 4095, TEXT("This value is true for any of the following conditions.:\n\t* The parameter g specified is not valid.\n\t* The WSAPROTOCOL_INFO structure that lpProtocolInfo points to is incomplete, the contents are invalid or the WSAPROTOCOL_INFO structure has already been used in an earlier duplicate socket operation.\n\t* The values specified for members of the socket triple <af, type, and protocol> are individually supported, but the given combination is not.\n")); break;
			case WSAEFAULT: _sntprintf(lastError, 4095, TEXT("The lpProtocolInfo parameter is not in a valid part of the process address space.\n")); break;
			default: _sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by WSASocket.\n"), dwError);
		}

		// Done with the window
		DestroyWindow(params->client->hNetworkWnd);

		// Clear the handle
		params->client->hNetworkWnd = NULL;

		// Call the error function
		params->client->OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

		// Signal the other thread
		SetEvent(params->client->hTmpEvent);

		// Failure
		return 0;
	}

	// Set asynchronous mode on the socket
	dwError = WSAAsyncSelect(params->client->sSocket, params->client->hNetworkWnd, WSAA_MSG1, FD_CLOSE | FD_READ | FD_CONNECT | FD_WRITE);

	// Check for errors
	if(dwError == SOCKET_ERROR)
	{
		// Get the error
		dwError = WSAGetLastError();

		// Handle the error
		switch(dwError)
		{
			case WSANOTINITIALISED: _sntprintf(lastError, 4095, TEXT("A successful WSAStartup call must occur before using this function.\n")); break;
			case WSAENETDOWN: _sntprintf(lastError, 4095, TEXT("The network subsystem failed.\n")); break;
			case WSAEINVAL: _sntprintf(lastError, 4095, TEXT("One of the specified parameters was invalid, such as the window handle not referring to an existing window, or the specified socket is in an invalid state.\n")); break;
			case WSAEINPROGRESS: _sntprintf(lastError, 4095, TEXT("A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.\n")); break;
			case WSAENOTSOCK: _sntprintf(lastError, 4095, TEXT("The descriptor is not a socket.\n")); break;
			default: _sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by WSAAsyncSelect.\n"), dwError);
		}

		// Close the socket
		closesocket(params->client->sSocket);

		// Connection socket
		params->client->sSocket = INVALID_SOCKET;

		// Done with the window
		DestroyWindow(params->client->hNetworkWnd);

		// Clear the handle
		params->client->hNetworkWnd = NULL;

		// Call the error function
		params->client->OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

		// Signal the other thread
		SetEvent(params->client->hTmpEvent);

		// Failure
		return 0;
	}

	// Check to see if we should do a host lookup
	if(params->doHostLookUp)
	{
		// Try to resolve the address of the server
		host = GetHost(params->address);
		if(host == NULL)
		{
			// Close the socket
			closesocket(params->client->sSocket);

			// Connection socket
			params->client->sSocket = INVALID_SOCKET;

			// Done with the window
			DestroyWindow(params->client->hNetworkWnd);

			// Clear the handle
			params->client->hNetworkWnd = NULL;

			// Build the error message
			_sntprintf(lastError, 4095, TEXT("The address %s could not be resolved.\n"), params->address);

			// Call the error function
			params->client->OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

			// Signal the other thread
			SetEvent(params->client->hTmpEvent);

			// Failure
			return 0;
		}

		// Setup the connection properties
		server.sin_addr.s_addr = *((unsigned long*)host->h_addr);
	}
	// Not doing a host lookup
	else
	{
		server.sin_addr.s_addr = inet_addr(params->address);
	}

	server.sin_family = AF_INET;
	server.sin_port = htons((u_short)params->port);

	// Try to connect
	if(connect(params->client->sSocket, (struct sockaddr*)&server, sizeof(server)))
	{
		// Handle the error
		dwError = WSAGetLastError();

		// This error is expected
		if(dwError != WSAEWOULDBLOCK )
		{
			// Handle the error
			switch(dwError)
			{
				case WSANOTINITIALISED: _sntprintf(lastError, 4095, TEXT("A successful WSAStartup call must occur before using this function.\n")); break;
				case WSAENETDOWN: _sntprintf(lastError, 4095, TEXT("The network subsystem has failed.\n")); break;
				case WSAEADDRINUSE: _sntprintf(lastError, 4095, TEXT("The socket's local address is already in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This error usually occurs when executing bind, but could be delayed until this function if the bind was to a partially wildcard address (involving ADDR_ANY) and if a specific address needs to be committed at the time of this function.\n")); break;
				case WSAEINTR: _sntprintf(lastError, 4095, TEXT("The blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.\n")); break;
				case WSAEINPROGRESS: _sntprintf(lastError, 4095, TEXT("A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.\n")); break;
				case WSAEALREADY: _sntprintf(lastError, 4095, TEXT("A nonblocking connect call is in progress on the specified socket.\nNote  In order to preserve backward compatibility, this error is reported as WSAEINVAL to Windows Sockets 1.1 applications that link to either Winsock.dll or Wsock32.dll.\n")); break;
				case WSAEADDRNOTAVAIL: _sntprintf(lastError, 4095, TEXT("The remote address is not a valid address (such as ADDR_ANY).\n")); break;
				case WSAEAFNOSUPPORT: _sntprintf(lastError, 4095, TEXT("Addresses in the specified family cannot be used with this socket.\n")); break;
				case WSAECONNREFUSED: _sntprintf(lastError, 4095, TEXT("The attempt to connect was forcefully rejected.\n")); break;
				case WSAEFAULT: _sntprintf(lastError, 4095, TEXT("The name or the namelen parameter is not a valid part of the user address space, the namelen parameter is too small, or the name parameter contains incorrect address format for the associated address family.\n")); break;
				case WSAEINVAL: _sntprintf(lastError, 4095, TEXT("The parameter s is a listening socket.\n")); break;
				case WSAEISCONN: _sntprintf(lastError, 4095, TEXT("The socket is already connected (connection-oriented sockets only).\n")); break;
				case WSAENETUNREACH: _sntprintf(lastError, 4095, TEXT("The network cannot be reached from this host at this time.\n")); break;
				case WSAEHOSTUNREACH: _sntprintf(lastError, 4095, TEXT("A socket operation was attempted to an unreachable host.\n")); break;
				case WSAENOBUFS: _sntprintf(lastError, 4095, TEXT("No buffer space is available. The socket cannot be connected.\n")); break;
				case WSAENOTSOCK: _sntprintf(lastError, 4095, TEXT("The descriptor is not a socket.\n")); break;
				case WSAETIMEDOUT: _sntprintf(lastError, 4095, TEXT("Attempt to connect timed out without establishing a connection.\n")); break;
				case WSAEWOULDBLOCK: _sntprintf(lastError, 4095, TEXT("The socket is marked as nonblocking and the connection cannot be completed immediately.\n")); break;
				case WSAEACCES: _sntprintf(lastError, 4095, TEXT("Attempt to connect datagram socket to broadcast address failed because setsockopt option SO_BROADCAST is not enabled.\n")); break;
				default: _sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by connect.\n"), dwError);
			}

			// Close the socket
			closesocket(params->client->sSocket);

			// Connection socket
			params->client->sSocket = INVALID_SOCKET;

			// Done with the window
			DestroyWindow(params->client->hNetworkWnd);

			// Clear the handle
			params->client->hNetworkWnd = NULL;

			// Call the error function
			params->client->OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

			// Signal the other thread
			SetEvent(params->client->hTmpEvent);

			// Failure
			return 0;
		}
	}

	// No error
	params->client->bTmpVar = true;

	// Signal the other thread
	SetEvent(params->client->hTmpEvent);

	// Store the window handle
	HWND h = params->client->hNetworkWnd;

	// Delete the memory allocated previously
	delete params;

	// Setup a timer for regular updating
	SetTimer(h, gTimerId, uElapse, 0);

	// Process while we have a message queue
	MSG Msg = {0};
	while(GetMessage(&Msg, 0, 0, 0) > 0)
	{
		TranslateMessage(&Msg);
		DispatchMessage(&Msg);
	}

	// Done with the window
	DestroyWindow(h);

	// Standard return
	return 0;
}

//-----------------------------------------------------------------------------

// This is the network message handling callback function
LRESULT CALLBACK edx::BaseTCPClient::ClientWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	// Get the client associated with the HWND
	BaseTCPClient * client = (BaseTCPClient *)UlongToPtr(GetWindowLong(hWnd, GWL_USERDATA));

	// Error string
	TCHAR lastError[4096] = {0};

	// Network message variables
	DWORD event = 0;
	DWORD dwError = 0;
	SOCKET currentSocket = 0;

	// Handle the message
	switch(uMsg)
	{
	case WM_TIMER:
		{
			if(wParam == gTimerId)
			{
				// No server to handle the network event
				if(client == 0)
				{
					return 0;
				}

				// Call the timer event
				client->OnTimer();
			}
		} break;

		// Quit message
	case WM_QUIT:
		{
			// If we have a valid client object
			if(client)
			{
				// Post the exit message
				PostThreadMessage(client->hNetworkThreadId, WM_QUIT, 0, 0);
			}
		} break;

		// Custom network event
	case WSAA_MSG1:
		{
			// Store the network event
			event = WSAGETSELECTEVENT(lParam);

			// Store the network error
			dwError = WSAGETSELECTERROR(lParam);

			// Store the current socket
			currentSocket = wParam;

			// No client to handle the network event
			if(client == 0)
			{
				return 0;
			}

			// Network is down 
			if(dwError == WSAENETDOWN)
			{
				// Build the error
				_sntprintf(lastError, 4095, TEXT("The network subsystem has failed."));

				// Call the error function
				client->OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

				// Do not forward this message
				return 0;
			}

			// Read event
			if(event == FD_READ)
			{
				client->OnRead();
			}
			// Write event
			else if(event == FD_WRITE)
			{
				client->OnWrite();
			}
			// Close event
			else if(event == FD_CLOSE)
			{
				// Now we know the client is no longer connected
				client->iConnected = 0;
				client->OnClose();
				closesocket(currentSocket);
			}
			// Connect event
			else if(event == FD_CONNECT)
			{
				// Check for an error
				if(dwError != 0)
				{
					// Handle the error
					switch(dwError)
					{
						case WSANOTINITIALISED: _sntprintf(lastError, 4095, TEXT("A successful WSAStartup call must occur before using this function.\n")); break;
						case WSAENETDOWN: _sntprintf(lastError, 4095, TEXT("The network subsystem has failed.\n")); break;
						case WSAEADDRINUSE: _sntprintf(lastError, 4095, TEXT("The socket's local address is already in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This error usually occurs when executing bind, but could be delayed until this function if the bind was to a partially wildcard address (involving ADDR_ANY) and if a specific address needs to be committed at the time of this function.\n")); break;
						case WSAEINTR: _sntprintf(lastError, 4095, TEXT("The blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.\n")); break;
						case WSAEINPROGRESS: _sntprintf(lastError, 4095, TEXT("A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.\n")); break;
						case WSAEALREADY: _sntprintf(lastError, 4095, TEXT("A nonblocking connect call is in progress on the specified socket.\nNote  In order to preserve backward compatibility, this error is reported as WSAEINVAL to Windows Sockets 1.1 applications that link to either Winsock.dll or Wsock32.dll.\n")); break;
						case WSAEADDRNOTAVAIL: _sntprintf(lastError, 4095, TEXT("The remote address is not a valid address (such as ADDR_ANY).\n")); break;
						case WSAEAFNOSUPPORT: _sntprintf(lastError, 4095, TEXT("Addresses in the specified family cannot be used with this socket.\n")); break;
						case WSAECONNREFUSED: _sntprintf(lastError, 4095, TEXT("The attempt to connect was forcefully rejected.\n")); break;
						case WSAEFAULT: _sntprintf(lastError, 4095, TEXT("The name or the namelen parameter is not a valid part of the user address space, the namelen parameter is too small, or the name parameter contains incorrect address format for the associated address family.\n")); break;
						case WSAEINVAL: _sntprintf(lastError, 4095, TEXT("The parameter s is a listening socket.\n")); break;
						case WSAEISCONN: _sntprintf(lastError, 4095, TEXT("The socket is already connected (connection-oriented sockets only).\n")); break;
						case WSAENETUNREACH: _sntprintf(lastError, 4095, TEXT("The network cannot be reached from this host at this time.\n")); break;
						case WSAEHOSTUNREACH: _sntprintf(lastError, 4095, TEXT("A socket operation was attempted to an unreachable host.\n")); break;
						case WSAENOBUFS: _sntprintf(lastError, 4095, TEXT("No buffer space is available. The socket cannot be connected.\n")); break;
						case WSAENOTSOCK: _sntprintf(lastError, 4095, TEXT("The descriptor is not a socket.\n")); break;
						case WSAETIMEDOUT: _sntprintf(lastError, 4095, TEXT("Attempt to connect timed out without establishing a connection.\n")); break;
						case WSAEWOULDBLOCK: _sntprintf(lastError, 4095, TEXT("The socket is marked as nonblocking and the connection cannot be completed immediately.\n")); break;
						case WSAEACCES: _sntprintf(lastError, 4095, TEXT("Attempt to connect datagram socket to broadcast address failed because setsockopt option SO_BROADCAST is not enabled.\n")); break;
						default: _sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by connect.\n"), dwError);
					}

					// Call the error function
					client->OnErrorFunction(__FILE__, __FUNCTION__, __LINE__, lastError);

					// Now we know the client failed to connect
					client->iConnected = 0;
				}
				else
				{
					// Now we know the client connected successfully
					client->iConnected = 1;

					// Successful connection
					client->OnConnect();
				}
			}
			// Do not forward this message
			return 0;
		} break;
	}

	// Default handler
	return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//-----------------------------------------------------------------------------

// Overloaded ctor to accept construction with a socket; we don't want objects without a socket!
edx::TCPClientInterface::TCPClientInterface(SOCKET s, TCPInterface * parent)
{
	// Track the socket on construction
	sSocket = s;
	parentInterface = parent;
	recvIndex = 0;
	sendQueueSize = 0;
	recvBuffer = 0;
	localRecvBuffer = 0;
	InitializeCriticalSection(&sendQueueCS);
}

//-----------------------------------------------------------------------------

// Default dtor
edx::TCPClientInterface::~TCPClientInterface()
{
	DeleteCriticalSection(&sendQueueCS);

	// Empty out any packets that were supposed to get sent that weren't
	while(!sendQueue.empty())
	{
		tPacketBuffer * buffer = sendQueue.front();
		delete buffer;
		sendQueue.pop();
	}
	delete [] recvBuffer;
	delete [] localRecvBuffer;
}

//-----------------------------------------------------------------------------

// Returns the socket of this object
SOCKET edx::TCPClientInterface::GetSocket() const
{
	return sSocket;
}

//-----------------------------------------------------------------------------

// Function to be called when the timer executes
void edx::TCPClientInterface::OnTimer()
{
	this->parentInterface->OnTimer();
}

//-----------------------------------------------------------------------------

// Called when a client connects to the server
bool edx::TCPClientInterface::OnConnect()
{
	// Info about the connecting client
	struct sockaddr_in addr = {0};
	socklen_t len = 0;
	char ip[32] = {0};
	WORD port;

	// Get the peer name of the connection
	len = sizeof(addr);
	getpeername(sSocket, (struct sockaddr*)&addr, &len);

	_snprintf(ip, 31, "%s", inet_ntoa(addr.sin_addr));
	port = ntohs(addr.sin_port);

	recvBuffer = new (std::nothrow) char[MAX_PACKET_SIZE];
	if(recvBuffer == 0)
	{
		// Do not accept the connection if we do not have enough memory for it (dtor will clean up memory)
		return false;
	}
	localRecvBuffer = new (std::nothrow) char[MAX_PACKET_SIZE];
	if(localRecvBuffer == 0)
	{
		// Do not accept the connection if we do not have enough memory for it (dtor will clean up memory)
		return false;
	}
	return parentInterface->TCPOnConnect(this, ip, port);
}

//-----------------------------------------------------------------------------

// Called when a client sends data to the server
void edx::TCPClientInterface::OnRead()
{
	// Recv index
	INT recvCount = 0;

	// Recv data - only enough to fill the recv buffer, not more
	recvCount = recv(sSocket, recvBuffer, MAX_PACKET_SIZE - recvIndex, 0);

	// Make sure there was not an error
	if(recvCount != SOCKET_ERROR)
	{
		// Copy it into the building buffer, recvIndex will never be > EDX_Max_Recv_Size
		// if the library is used correctly.
		memcpy(localRecvBuffer + recvIndex, recvBuffer, recvCount);

		// Increase the index
		recvIndex += recvCount;

		// Call the user function to process the stream, should return -1 if there is not a full packet yet
		// or any number that tells how many bytes were processed
		INT result = this->parentInterface->TCPOnProcessStream(this, (WORD)recvIndex, (LPBYTE)localRecvBuffer);

		// Loop while we have a full packet
		while(result != -1)
		{
			// Decrease buffer size
			recvIndex -= result;

			// Physically overwrite existing data, we have to do this, no way around it without
			// making things way more complicated. By doing this also, we guarantee that we will
			// never overflow our packet buffer if everything is used correctly.
			if(recvIndex)
			{
				// Move the data that is left into the start of the buffer
				memmove(localRecvBuffer, localRecvBuffer + result, recvIndex);

				// Call the user function to process the stream, should return -1 if there is not a full packet yet
				// or any number that tells how many bytes were processed
				result = this->parentInterface->TCPOnProcessStream(this, (WORD)recvIndex, (LPBYTE)localRecvBuffer);
			}
			else
			{
				// If there is no data left, then we do not need to call UserProcessStream,
				// so we are done in this loop
				break;
			}
		}
	}
	else
	{
		DWORD dwError = WSAGetLastError();
		if(dwError != WSAEWOULDBLOCK)
		{
			switch(dwError)
			{
				case WSANOTINITIALISED: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("A successful WSAStartup call must occur before using this function.")); break;
				case WSAENETDOWN: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The network subsystem has failed.")); break;
				case WSAEFAULT: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The buf parameter is not completely contained in a valid part of the user address space.")); break;
				case WSAENOTCONN: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The socket is not connected.")); break;
				case WSAEINTR: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The (blocking) call was canceled through WSACancelBlockingCall.")); break;
				case WSAEINPROGRESS: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.")); break;
				case WSAENETRESET: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("For a connection-oriented socket, this error indicates that the connection has been broken due to keep-alive activity detecting a failure while the operation was in progress. For a datagram socket, this error indicates that the time to live has expired.")); break;
				case WSAENOTSOCK: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The descriptor is not a socket.")); break;
				case WSAEOPNOTSUPP: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the communication domain associated with this socket, or the socket is unidirectional and supports only send operations.")); break;
				case WSAESHUTDOWN: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The socket has been shut down; it is not possible to receive on a socket after shutdown has been invoked with how set to SD_RECEIVE or SD_BOTH.")); break;
				case WSAEWOULDBLOCK: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The socket is marked as nonblocking and the receive operation would block.")); break;
				case WSAEMSGSIZE: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The message was too large to fit into the specified buffer and was truncated.")); break;
				case WSAEINVAL: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The socket has not been bound with bind, or an unknown flag was specified, or MSG_OOB was specified for a socket with SO_OOBINLINE enabled or (for byte stream sockets only) len was zero or negative.")); break;
				case WSAECONNABORTED: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The virtual circuit was terminated due to a time-out or other failure. The application should close the socket as it is no longer usable.")); break;
				case WSAETIMEDOUT: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The connection has been dropped because of a network failure or because the peer system failed to respond.")); break;
				case WSAECONNRESET: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The virtual circuit was reset by the remote side executing a hard or abortive close. The application should close the socket as it is no longer usable. On a UPD-datagram socket this error would indicate that a previous send operation resulted in an ICMP \"Port Unreachable\" message.")); break;
				default: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("Unhandled recv error."));
			}
		}
	}
}

//-----------------------------------------------------------------------------

// Called when a client is ready for more data to be sent
void edx::TCPClientInterface::OnWrite()
{
	EnterCriticalSection(&sendQueueCS);
	while(sendQueue.size())
	{
		// Store the first packet in the queue
		edx::tPacketBuffer * packetBuffer = sendQueue.front();

		// Try to send the entire packet
		INT result = send(sSocket, packetBuffer->data + packetBuffer->index, packetBuffer->size - packetBuffer->index, 0);

		// If we sent the entire packet, free memory and remove the entry
		if(result == packetBuffer->size)
		{
			sendQueueSize -= result;
			delete packetBuffer;
			sendQueue.pop();
		}

		// If we got an error
		else if(result == -1)
		{
			DWORD dwError = WSAGetLastError();
			// If we cannot send any more data, break out of the loop since another FD_SEND will be posted
			if(dwError == WSAEWOULDBLOCK)
			{
				break;
			}
			else
			{
				switch(dwError)
				{
					case WSANOTINITIALISED: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("A successful WSAStartup call must occur before using this function.")); break;
					case WSAENETDOWN: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The network subsystem has failed.")); break;
					case WSAEACCES: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The requested address is a broadcast address, but the appropriate flag was not set. Call setsockopt with the SO_BROADCAST socket option to enable use of the broadcast address.")); break;
					case WSAEINTR: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("A blocking Windows Sockets 1.1 call was canceled through WSACancelBlockingCall.")); break;
					case WSAEINPROGRESS: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.")); break;
					case WSAEFAULT: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The buf parameter is not completely contained in a valid part of the user address space.")); break;
					case WSAENETRESET: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The connection has been broken due to the keep-alive activity detecting a failure while the operation was in progress.")); break;
					case WSAENOBUFS: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("No buffer space is available.")); break;
					case WSAENOTCONN: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The socket is not connected.")); break;
					case WSAENOTSOCK: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The descriptor is not a socket.")); break;
					case WSAEOPNOTSUPP: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the communication domain associated with this socket, or the socket is unidirectional and supports only receive operations.")); break;
					case WSAESHUTDOWN: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The socket has been shut down; it is not possible to send on a socket after shutdown has been invoked with how set to SD_SEND or SD_BOTH.")); break;
					case WSAEWOULDBLOCK: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The socket is marked as nonblocking and the requested operation would block.")); break;
					case WSAEMSGSIZE: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The socket is message oriented, and the message is larger than the maximum supported by the underlying transport.")); break;
					case WSAEHOSTUNREACH: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The remote host cannot be reached from this host at this time.")); break;
					case WSAEINVAL: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The socket has not been bound with bind, or an unknown flag was specified, or MSG_OOB was specified for a socket with SO_OOBINLINE enabled.")); break;
					case WSAECONNABORTED: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The virtual circuit was terminated due to a time-out or other failure. The application should close the socket as it is no longer usable.")); break;
					case WSAECONNRESET: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The virtual circuit was reset by the remote side executing a hard or abortive close. For UDP sockets, the remote host was unable to deliver a previously sent UDP datagram and responded with a \"Port Unreachable\" ICMP packet. The application should close the socket as it is no longer usable.")); break;
					case WSAETIMEDOUT: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("The connection has been dropped, because of a network failure or because the system on the other end went down without notice.")); break;
					default: this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, TEXT("Unhandled send error."));
				}
			}
		}

		// Otherwise, we sent a partial message so update the start index
		else
		{
			packetBuffer->index = packetBuffer->index + (WORD)result;
			sendQueueSize -= result;
		}
	}
	LeaveCriticalSection(&sendQueueCS);
}

//-----------------------------------------------------------------------------

// Called when a client closes the connection to the server
void edx::TCPClientInterface::OnClose()
{
	// Remove any buffered packets to prevent leaks
	while(!sendQueue.empty())
	{
		tPacketBuffer * buffer = sendQueue.front();
		delete buffer;
		sendQueue.pop();
	}
	this->parentInterface->TCPOnClose(this);
}

//-----------------------------------------------------------------------------

// Sends a packet through this client interface
void edx::TCPClientInterface::Send(WORD count, LPBYTE stream)
{
	// If we have packets buffered already, do not try to send, simply buffer them to prevent out of order messages
	if(sendQueue.size())
	{
		tPacketBuffer * buffer = new (std::nothrow) tPacketBuffer;
		// At this point, we have data that needs to be sent, but we have no way of storing it
		if(buffer == 0)
		{
			// What is the best course of action to take? For now, we will just disconnect the interface
			// since we do not want invalid data. This might not be the best thing to do, but it is 
			// application specific. Perhaps this function could return false if the packet could not be
			// buffered...
			Disconnect();
			return;
		}
		memset(buffer, 0, sizeof(tPacketBuffer));
		buffer->size = count;
		memcpy(buffer->data, stream, count);
		EnterCriticalSection(&sendQueueCS);
			sendQueue.push(buffer);
		LeaveCriticalSection(&sendQueueCS);
		sendQueueSize += buffer->size;
		return;
	}

	// Try to send the packer size first
	INT result = send(sSocket, (char *)stream, count, 0);

	// If it was not sent
	if(result != count)
	{
		// If no data was sent at all
		if(result == -1)
		{
			DWORD dwError = WSAGetLastError();
			if(dwError == WSAEWOULDBLOCK)
			{
				tPacketBuffer * buffer = new (std::nothrow) tPacketBuffer;
				if(buffer == 0)
				{
					// What is the best course of action to take? For now, we will just disconnect the interface
					// since we do not want invalid data. This might not be the best thing to do, but it is 
					// application specific. Perhaps this function could return false if the packet could not be
					// buffered...
					Disconnect();
					return;
				}
				memset(buffer, 0, sizeof(tPacketBuffer));
				buffer->size = count;
				memcpy(buffer->data, stream, count);
				EnterCriticalSection(&sendQueueCS);
					sendQueue.push(buffer);
				LeaveCriticalSection(&sendQueueCS);
				sendQueueSize += buffer->size;
			}
			else
			{
				TCHAR lastError[4096] = {0};
				switch(dwError)
				{
					case WSANOTINITIALISED: _sntprintf(lastError, 4095, TEXT("A successful WSAStartup call must occur before using this function.")); break;
					case WSAENETDOWN: _sntprintf(lastError, 4095, TEXT("The network subsystem has failed.")); break;
					case WSAEACCES: _sntprintf(lastError, 4095, TEXT("The requested address is a broadcast address, but the appropriate flag was not set. Call setsockopt with the SO_BROADCAST socket option to enable use of the broadcast address.")); break;
					case WSAEINTR: _sntprintf(lastError, 4095, TEXT("A blocking Windows Sockets 1.1 call was canceled through WSACancelBlockingCall.")); break;
					case WSAEINPROGRESS: _sntprintf(lastError, 4095, TEXT("A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.")); break;
					case WSAEFAULT: _sntprintf(lastError, 4095, TEXT("The buf parameter is not completely contained in a valid part of the user address space.")); break;
					case WSAENETRESET: _sntprintf(lastError, 4095, TEXT("The connection has been broken due to the keep-alive activity detecting a failure while the operation was in progress.")); break;
					case WSAENOBUFS: _sntprintf(lastError, 4095, TEXT("No buffer space is available.")); break;
					case WSAENOTCONN: _sntprintf(lastError, 4095, TEXT("The socket is not connected.")); break;
					case WSAENOTSOCK: _sntprintf(lastError, 4095, TEXT("The descriptor is not a socket.")); break;
					case WSAEOPNOTSUPP: _sntprintf(lastError, 4095, TEXT("MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the communication domain associated with this socket, or the socket is unidirectional and supports only receive operations.")); break;
					case WSAESHUTDOWN: _sntprintf(lastError, 4095, TEXT("The socket has been shut down; it is not possible to send on a socket after shutdown has been invoked with how set to SD_SEND or SD_BOTH.")); break;
					case WSAEWOULDBLOCK: _sntprintf(lastError, 4095, TEXT("The socket is marked as nonblocking and the requested operation would block.")); break;
					case WSAEMSGSIZE: _sntprintf(lastError, 4095, TEXT("The socket is message oriented, and the message is larger than the maximum supported by the underlying transport.")); break;
					case WSAEHOSTUNREACH: _sntprintf(lastError, 4095, TEXT("The remote host cannot be reached from this host at this time.")); break;
					case WSAEINVAL: _sntprintf(lastError, 4095, TEXT("The socket has not been bound with bind, or an unknown flag was specified, or MSG_OOB was specified for a socket with SO_OOBINLINE enabled.")); break;
					case WSAECONNABORTED: _sntprintf(lastError, 4095, TEXT("The virtual circuit was terminated due to a time-out or other failure. The application should close the socket as it is no longer usable.")); break;
					case WSAECONNRESET: _sntprintf(lastError, 4095, TEXT("The virtual circuit was reset by the remote side executing a hard or abortive close. For UDP sockets, the remote host was unable to deliver a previously sent UDP datagram and responded with a \"Port Unreachable\" ICMP packet. The application should close the socket as it is no longer usable.")); break;
					case WSAETIMEDOUT: _sntprintf(lastError, 4095, TEXT("The connection has been dropped, because of a network failure or because the system on the other end went down without notice.")); break;
					default: _sntprintf(lastError, 4095, TEXT("Unhandled error: [%i] generated by send."), dwError);
				}
				// Call the error function
				this->parentInterface->TCPOnError(this, __FILE__, __FUNCTION__, __LINE__, lastError);
			}
			return;
		}

		// If we get here, only part of the packet was sent
		else
		{
			tPacketBuffer * buffer = new (std::nothrow) tPacketBuffer;
			if(buffer == 0)
			{
				// What is the best course of action to take? For now, we will just disconnect the interface
				// since we do not want invalid data. This might not be the best thing to do, but it is 
				// application specific. Perhaps this function could return false if the packet could not be
				// buffered...
				Disconnect();
				return;
			}
			memset(buffer, 0, sizeof(tPacketBuffer));
			buffer->size = count;
			memcpy(buffer->data, stream, count);
			buffer->size = count - (WORD)result;
			memmove(buffer->data, buffer->data + result, buffer->size);
			EnterCriticalSection(&sendQueueCS);
				sendQueue.push(buffer);
			LeaveCriticalSection(&sendQueueCS);
			sendQueueSize += buffer->size;
			return;
		}
	}
}

//-----------------------------------------------------------------------------

// Disconnects the socket
void edx::TCPClientInterface::Disconnect()
{
	shutdown(sSocket, 0x02);
}

//-----------------------------------------------------------------------------

// Returns the total number of bytes that are queued for sending
size_t edx::TCPClientInterface::GetSendQueueSize()
{
	return sendQueueSize;
}

//-----------------------------------------------------------------------------

// Returns how many packets are queued for sending
size_t edx::TCPClientInterface::GetSendQueueCount()
{
	size_t size = 0;
	EnterCriticalSection(&sendQueueCS);
		size = sendQueue.size();
	LeaveCriticalSection(&sendQueueCS);
	return size;
}

//-----------------------------------------------------------------------------

// Default ctor
edx::TCPServer::TCPServer()
{
}

//-----------------------------------------------------------------------------

// Default dtor
edx::TCPServer::~TCPServer()
{
	std::map<SOCKET, TCPClientInterface *>::iterator itr = connections.begin();
	while(itr != connections.end())
	{
		TCPClientInterface * ptr = itr->second;
		delete ptr;
		itr++;
	}
}

//-----------------------------------------------------------------------------

// Function called when a client has connected to the server
void edx::TCPServer::OnConnect(SOCKET s)
{
	TCPClientInterface * client = new (std::nothrow) TCPClientInterface(s, this);
	if(client == 0)
	{
		// Silent connection closing since there is not enough memory avaliable
		closesocket(s);
	}
	if(client->OnConnect() == true)
	{
		connections.insert(std::make_pair(s, client));
	}
	else
	{
		delete client;
		closesocket(s);
	}
}

//-----------------------------------------------------------------------------

// Function called when a socket is ready for reading
void edx::TCPServer::OnRead(SOCKET s)
{
	std::map<SOCKET, TCPClientInterface *>::iterator itr = connections.find(s);
	if(itr != connections.end())
	{
		itr->second->OnRead();
	}
}

//-----------------------------------------------------------------------------

// Function called when a socket is ready for writing
void edx::TCPServer::OnWrite(SOCKET s)
{
	std::map<SOCKET, TCPClientInterface *>::iterator itr = connections.find(s);
	if(itr != connections.end())
	{
		itr->second->OnWrite();
	}
}

//-----------------------------------------------------------------------------

// Function called when a socket was closed
void edx::TCPServer::OnClose(SOCKET s)
{
	std::map<SOCKET, TCPClientInterface *>::iterator itr = connections.find(s);
	if(itr != connections.end())
	{
		itr->second->OnClose();
		delete itr->second;
		connections.erase(itr);
	}
}

//-----------------------------------------------------------------------------

// Function called when an error occurs
void edx::TCPServer::OnErrorFunction(CONST CHAR * file, CONST CHAR * function, CONST INT line, CONST TCHAR * error)
{
	TCPOnError(0, file, function, line, error);
}

//-----------------------------------------------------------------------------

// Default ctor
edx::TCPClient::TCPClient()
{
	clientInterface = 0;
}

//-----------------------------------------------------------------------------

// Default dtor
edx::TCPClient::~TCPClient()
{
	if(clientInterface)
	{
		delete clientInterface;
	}
}

//-----------------------------------------------------------------------------

// Function called when a client has connected to the server
void edx::TCPClient::OnConnect()
{
	// Make sure we don't leak memory if the connection failed,
	// and then we try again
	if(clientInterface)
	{
		delete clientInterface;
		clientInterface = 0;
	}

	// Allocate memory for a new connection
	clientInterface = new (std::nothrow) TCPClientInterface(sSocket, this);
	if(clientInterface == 0)
	{
		// Mark the socket for closing
		shutdown(sSocket, 0x02);
	}

	// Try to connect
	if(clientInterface->OnConnect() == false)
	{
		// Mark the socket for closing
		shutdown(sSocket, 0x02);
	}
}

//-----------------------------------------------------------------------------

// Function called when a socket is ready for reading
void edx::TCPClient::OnRead()
{
	clientInterface->OnRead();
}

//-----------------------------------------------------------------------------

// Function called when a socket is ready for writing
void edx::TCPClient::OnWrite()
{
	clientInterface->OnWrite();
}

//-----------------------------------------------------------------------------

// Function called when a socket was closed
void edx::TCPClient::OnClose()
{
	clientInterface->OnClose();
}

//-----------------------------------------------------------------------------

// Function called when an error occurs
void edx::TCPClient::OnErrorFunction(CONST CHAR * file, CONST CHAR * function, CONST INT line, CONST TCHAR * error)
{
	TCPOnError(clientInterface, file, function, line, error);
}

//-----------------------------------------------------------------------------

// Sends a packet through the client interface
void edx::TCPClient::Send(WORD size, LPBYTE stream)
{
	clientInterface->Send(size, stream);
}

//-----------------------------------------------------------------------------

// Disconnect the socket
void edx::TCPClient::Disconnect()
{
	clientInterface->Disconnect();
}

//-----------------------------------------------------------------------------

// Returns the socket of this object
SOCKET edx::TCPClient::GetSocket() const
{
	return clientInterface->GetSocket();
}

//-----------------------------------------------------------------------------

// Returns how many packets are queued for sending
size_t edx::TCPClient::GetSendQueueSize()
{
	return clientInterface->GetSendQueueSize();
}

//-----------------------------------------------------------------------------

// Returns how many packets are queued for sending
size_t edx::TCPClient::GetSendQueueCount()
{
	return clientInterface->GetSendQueueCount();
}

//-----------------------------------------------------------------------------
